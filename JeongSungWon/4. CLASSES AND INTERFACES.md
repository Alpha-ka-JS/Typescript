## class
- JS에서는 private, public이 잘못되도 문제 없이 실행되지만, TS에서는 오류가 나옴
```TS
class Player {
    construtor (
        private firstName:string, // 선언한 곳 안에서만 사용 가능
        private lastName:string,
        public nickname:string, // 어디서든지 접근 가능
    ) {}
}

const sungwon = new Player("sungwon", "jeong", "성원");
sungwon.firstName; // firstName은 private임으로 오류
sungwon.nickname; // nickname은 public으로 사용 가능
```

## abstract
- 추상클래스 : 다른 클래스의 상속을 받을 수 있는 클래스
- 추상클래스로 새로운 인스턴스 생성 불가(new User 사용 불가)
- JS에서 문제없이 abstract가 없으므로 정상 작동
- 추상메서드를 사용하고 싶으면 call signature 선언
```TS
abstract class User {
     construtor (
        private firstName:string, // 선언한 곳 안에서만 사용 가능
        private lastName:string,
        public nickname:string,
        protected nickname1: string,
    ) {}

    abstract getNickName(): void // call signature 사용하면 추상메서드가 됨으로 Player class에서 구현이되야함

    getFullName() {
        return `${this.firstName} ${this.lastName}`
    }

    private getFullName1() {
        return `${this.firstName} ${this.lastName}`
    }
}

class Player extends User {
    getNickName() {
        console.log(nickname); // private 임으로 호출 X
        console.log(nickname); // protected 는 상속 받을 곳에 사용. 호출 O
    }
}

const sungwon = new Player("sungwon", "jeong", "성원");
sungwon.getFullName() // 정상 동작
sungwon.getFullName1() // 오류 > private 접근 X
```

## class & abstract 예제

```TS
type Words = {
    [key:string]: string // [key:string] 의미는 string만을 property로 가지는 object라는걸 의미
}

class Dict {
    private words: Words
    constructor() {
        this.words = {}
    }

    add(word:Word) {
        if(this.words[word.term] === undefined) {
            this.words[word.term] = word.def;
        }
    }

    def(term:string) {
        return this.words[term]
    }
}

class Word {
    constructor(
        public term :string,
        public def :string,
    ) {}
}

const kimchi = new Word("kimchi", "한국의 음식")

const dict = new Dict()

dict.add(kimchi)
dict.def("kimchi")
```

## interface
- 객체의 모양을 설명해주기 위해 존재
- 인터페이스는 type과는 달리 오직 객체일 때만 사용이 가능하다.
- interface는 type과 달리 여러번 선언 가능
```TS
type Team = 'red' | 'blue' | 'yellow'
type Health = 1 | 5 | 10

// type 
type Player = {
    nickname: string,
    team: Team
    health: Health
}

type name = string

// interface
interface Player {
    nickname: string,
    team: Team,
    health: Health
}

// interface name = string  사용 X

// interface를 상속해서 사용
interface User {
    name: string
}

interface Player extends User {}

const sungwon : Player = {
    name: "sungwon"
}

// interface 여러번 선언 가능
interface Player {
    firstName: string
}

interface Player {
    lastName: string
}

const sungwon : Player {
    firstName: "sungwon",
    lastName: "jeong"
}
```
